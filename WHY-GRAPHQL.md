what makes graphql exciting to devs

- agnostic - it can serve data to any front end, react / angular / or serve for any other app (not broweser)
- serves as an API
- replaces CRUD with 1 endpoint. 1 ENDPOINT. 1 ENDPOINT. 
- more secure - cannot as easily guess mutation names, we can easily protect mutations for different user permissions - i.e. public vs. admin, not logged in user / logged in user / author / editor / god privilegs
- looks like JSON
- no need to learn how THIS api works. Works the same, every time. no need to learn how THIS api defines POST PUT DELETE routes. 
- we instead request the data we need, instead of figuring out WHICH route sends THAT data. 

- either serves AS the api or SITS IN FRONT of the API


CORE IDEAS

single endpoint shows queries & mutations
no routes

- GraphQL is a way to ask for only what you want for the front end
- GraphQL then uses formulas called resolvers to request that data from the server, and send as a package to the front end in exactly the shape / format requested
- GraphQL is a standard to request data FROM SQL or Mongo 
- it's build nadn formatted the same every time, each time. once you know how graphql is formatted, a front end dev does not have to relearn a new API format

WALKTHROUGH

Front End

2. BACK END COMPONENTS

2.1 DATABASE

- prisma folder -->
- prisma.yml is the root configuration file for the service.
- datamodel.graphql defines your data model in the GraphQL Schema Definition Language (SDL). The data model is the foundation for the GraphQL API generated by Prisma which provides powerful CRUD operations for the types in the data model.

2.2 GRAPHQL SERVER

- src folder -- >
- schema.graphql contains your application schema. The application schema defines the GraphQL operations you can send from the frontend. We’ll take a closer look at this file in just a bit
- generated/prisma.graphql contains the auto-generated Prisma database schema. The Prisma schema defines powerful CRUD operations for the types in your data model. Note that you should never edit this file manually since it gets automatically updated when the data model changes.
- resolvers contains the resolver functions for the operations defined in the application schema.
- index.js is the entry point for your GraphQL server.

2.3 FOR FRONT END DEVS

- the data we can send to or request from GRAPHQL is defined in `server/src/schema.graphql`

2.4 INTERACTIVE QUERIES.MUTATIONS IN BROWSER / PLAYGROUDN

- cd into ~/server
- run `yarn start`
- go to localhost:4000
- check it out! built in documentation for this GraphQL API

2.5 WHAT DOES THIS LOOK LIKE
(https://imgur.com/M8cbht4.png)


2.6 Cool, so how do we send REQUEST or SEND DATA ? 
Apollo. 
Apollo. coNNECTS react to graphql. 
- We're going to write a query as `gql`. 
- We'll pass it as a PROP. YES A PROP. TO GRAPHQL. 
- Dude. The results WILL COME BACK into the component FROM GRAPHQL. 

- we want to send data? write it as a `gql`
- send as a mutation, using the mutation component
- we'll get that data BACK into the component AGAIN

2.7 Sweet. we've built queries and mutations. 
Let's add Apollo & context as Middleware. 
- go to index.js
- we need apollo to send this stuff. 
- see the config - const authLink & const client. this is in apollo.js in Surrey

Apollo's caching
-- mutation in Link.js waits until the server repsponsd, then uses update = to update the UI based on apollo's cachinhg
-- actually done by linklist.js, the _updateCacheAfterVote () function

2.8 we're moving on to adding search functionality
-- search.js

2.9 GraphQL subscriptions (copy paste section)
- Subscriptions are a GraphQL feature allowing the server to send data to its clients when a specific event happens. 
- Subscriptions are usually implemented with WebSockets, where the server holds a steady connection to the client. 
-This means when working with subscriptions, you’re breaking the Request-Response-Cycle that was used for all previous interactions with the API. 
- The client now initiates a steady connection with the server by specifying which event it is interested in. Every time this particular event then happens, the server uses the connection to push the expected data to the client.

- we're going to set up websockets to listen for when 
-- a new link is created
-- an existing link is updated
-- an existing link is deleted

2.91 Let's do a subscription!
- set up split screen localhost:3000 & localhost:4000
- we're going to watch as we add a mutation & see the link list update in real time
- in locaholhost:4000 add this: 
```
mutation {
  post(
    url: "https://www.youtube.com/watch?v=c8xJtH6UcQY"
    description: "foxes jumping on my trampoline"
  ) {
    id
  }
}
```